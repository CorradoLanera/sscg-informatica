---
title: '[Manipolazione]{style="color:darkorange;"}'
subtitle: "~30 min"
format:
  revealjs:
    width:  1648 #(3/2)
    height: 1080
    logo: img/UBEP.png
    footer: "SSCG Informatica di Base - I anno"
    slide-number: true
    history: false
    preview-links: auto
    code-link: true
    chalkboard:
      src: src/chalkboard-manipolazione.json
bibliography: references.bib
---

```{r}
#| label: setup
#| include: false
knitr::opts_chunk$set(
  echo = TRUE
)
library(dplyr)
library(countdown)
```

## Import di dati `{rio}`

::: callout-tip
Possiamo usare il pacchetto `{rio}` per leggerli tutti!

- `?rio::import` fornisce un'esperienza di importazione dei dati indolore, scegliendo automaticamente la funzione di importazione/lettura appropriata in base all'estensione del file (o a un argomento di formato specificato).

- `?rio::export` fornisce lo stesso riconoscimento indolore dei file per la funzionalità di esportazione/scrittura dei dati.
:::


## `{rio}` - lettura

::: panel-tabset
## CSV

```{r}
#| paged.print: FALSE
library(here)
library(rio)

# {rio} default import is a simple data.frame
here("data-raw", "Copenhagen_clean.csv") |>
  import() |>
  head()
```

## Excel

```{r}
#| paged.print: FALSE
library(here)
library(rio)

# L'importazione predefinita di {rio} è un semplice data.frame.

# Ma si può chiedere alla classe dell'oggetto importato di essere
# uns tibble!
here("data-raw", "Copenhagen_clean.xlsx") |>
  import(setclass = "tibble")
```

## SAS

```{r}
#| paged.print: FALSE
library(here)
library(rio)

# L'importazione predefinita di {rio} è un semplice data.frame
# Si può anche impostare la classe {rio} di importazione a livello globale
options(rio.import.class = "tibble")

import(
  "http://www.principlesofeconometrics.com/sas/airline.sas7bdat"
)
```
:::

... e [molti altri](https://gesistsa.github.io/rio/#supported-file-formats)

## `{rio}` - scrittura

::: panel-tabset
## CSV

```{r}
#| paged.print: FALSE
Copenhagen_clean <- here("data-raw", "Copenhagen_clean.csv") |>
  import()

Copenhagen_clean |>
  # export() restituisce il percorso di uscita
  # in modo da poterlo riportare in pipe a import
  export(here("output", "Copenhagen_clean.csv")) |>
  import()
```

## Excel

```{r}
#| paged.print: FALSE
Copenhagen_clean |>
  export(here("output", "Copenhagen_clean.xlsx")) |>
  import()
```

## SAS

```{r}
#| paged.print: FALSE
Copenhagen_clean |>
  export(here("output", "Copenhagen_clean.sas7bdat")) |>
  import()
```

## STATA

```{r}
#| paged.print: FALSE
Copenhagen_clean |>
  export(here("output", "Copenhagen_clean.dta")) |>
  import()
```

## SPSS

```{r}
#| paged.print: FALSE
Copenhagen_clean |>
  export(here("output", "Copenhagen_clean.sav")) |>
  import()
```
:::


# Manipolazione di dati `{dplyr}`

## `dplyr` - intro

Struttura comune:

- Il primo argomento è sempre un frame di dati
- Gli argomenti successivi descrivono tipicamente le colonne su cui operare, utilizzando i nomi delle variabili (senza virgolette).
- L'output è sempre un nuovo frame di dati.
- Dunque, puoi sempre concatenare più operazioni insieme usando il pipe (`|>`).

## Righe - `dplyr::filter`

::: callout-important
`dplyr::filter` consente di mantenere le righe in base ai valori delle colonne.
:::

```{r}
library(dplyr)
library(here)
library(rio)

db <- here("data-raw", "Copenhagen_clean.xlsx") |>
  import(setclass = "tibble")

db |>
  filter(age < 18)
```

## Rows - conditions

Possiamo utilizzare qualsiasi tipo di condizione all'interno di `dplyr::filter`; per esempio,

### E

```{r}
db |>
  filter((age < 18) & case)
```


## Righe - condizioni

Possiamo utilizzare qualsiasi tipo di condizione all'interno di `dplyr::filter`; per esempio,

### O

```{r}
db |>
  filter(gastrosymptoms | ate_anything)
```

## Righe - condizioni

Possiamo utilizzare qualsiasi tipo di condizione all'interno di `dplyr::filter`; per esempio,

### In

```{r}
db |>
  filter(age %in% 19:25)
```

## Righe - condizioni

Possiamo utilizzare qualsiasi tipo di condizione all'interno di `dplyr::filter`; per esempio,


### Diverso (non uguale)

```{r}
db |>
  filter(group != "student")
```



## Colonne - `dplyr::select`

Per le analisi, non è necessario in genere rimuovere le colonne dal dataset, ma potrebbe essere estremamente utile per vedere più chiaramente solo i dati che si devono vedere di volta in volta.[^4]

[^4]: https://tidyselect.r-lib.org/reference/language.html

È possibile selezionare la colonna da mantenere utilizzando il verbo `dplyr::select()`:

### Le variabili che si desidera mantenere

```{r}
library(dplyr)

db |>
  select(sex, age, case)
```

## Colonne - `dplyr::select`

Per le analisi, non è necessario in genere rimuovere le colonne dal dataset, ma potrebbe essere estremamente utile per vedere più chiaramente solo i dati che si devono vedere di volta in volta.

È possibile selezionare la colonna da mantenere utilizzando il verbo `dplyr::select()`:

### Una gamma di variabili che si desidera mantenere

```{r}
library(dplyr)

db |>
  select(sex:class)
```

## Colonne - `dplyr::select`

Per le analisi, non è necessario in genere rimuovere le colonne dal dataset, ma potrebbe essere estremamente utile per vedere più chiaramente solo i dati che si devono vedere di volta in volta.


È possibile selezionare la colonna da mantenere utilizzando il verbo `dplyr::select()`:

### Escludere la selezione (`!`)

```{r}
library(dplyr)

db |>
  select(!diarrhoea:jointpain)
```

## Colonne - `dplyr::select`

Per le analisi, non è necessario in genere rimuovere le colonne dal dataset, ma potrebbe essere estremamente utile per vedere più chiaramente solo i dati che si devono vedere di volta in volta.



È possibile selezionare la colonna da mantenere utilizzando il verbo `dplyr::select()`:

### Corrispondenza di una condizione - `where`

```{r}
library(dplyr)

db |>
  select(where(is.logical))
```

## Selettori [^2]

[^2]: https://tidyselect.r-lib.org/reference/language.html

- `var1:var10`: variabili comprese tra var1 a sinistra e var10 a destra.

- `starts_with("a")`: nomi che iniziano con "a".

- `ends_with("z")`: nomi che terminano con "z".

- `contains("b")`: nomi che contengono "b".

- `matches("x.y")`: nomi che corrispondono all'espressione regolare `x.y`. [^3]

- `num_range(x, 1:4)`: nomi che seguono lo schema, `x1`, `x2`, ..., `x4`.

- `all_of(vars)/any_of(vars)`: nomi memorizzati nel vettore di caratteri vars. `all_of(vars)` dà errore se le variabili non sono presenti; `any_of(var)` corrisponde solo alle variabili esistenti.

[^3]: Non vedremo le espressioni regolari in questo corso, ma sono n potente e trasversale strumento per la manipolazione di stringhe che suggerisco di approfondire.

## Mutate
È possibile aggiungere nuove colonne calcolate a partire da quelle esistenti.

### Possiamo usare una semplice algebra

```{r}
library(dplyr)
library(here)
library(rio)

db <- here("data-raw", "Copenhagen_clean.xlsx") |>
  import(setclass = "tibble")

db |>
  # select just to return few results
  select(id, incubation) |>
  mutate(
    incubation_days = incubation / 24
  )
```

## Mutate

Si possono anche aggiungere nuove colonne calcolate a partire da quelle esistenti.

### Possiamo usare le funzioni sulle variabili

```{r}
library(dplyr)

db |>
  # select just to return few results
  select(id, incubation) |>
  mutate(
    incubation_norm = (
      incubation - mean(incubation, na.rm = TRUE)
    ) / sd(incubation, na.rm = TRUE)
  )
```

## Mutate

Si possono anche aggiungere nuove colonne calcolate a partire da quelle esistenti.

### We can use variables just created

```{r}
library(dplyr)

db |>
  # select just to return few results
  select(id, age, group, class, case) |>
  mutate(
    adult = (age > 18) & (
      (group != "student") |
      is.na(class)
    ),
    adult_case = adult & case
  )
```

## Mutate

Si possono anche aggiungere nuove colonne calcolate a partire da quelle esistenti.

### Prestare attenzione alle funzioni vettoriali e a quelle di sintesi.

::: columns
::: {.column width="75%"}
```{r}
#| output-location: default
library(dplyr)

sample_df <- tibble(
  x = c(1, 5, 7),
  y = c(3, 2, NA)
)

sample_df |>
  mutate(
    # rows element-wise
    min_vec = pmin(x, y, na.rm = TRUE),
    max_vec = pmax(x, y, na.rm = TRUE),
    # cols global
    min_all = min(x, y, na.rm = TRUE),
    max_all = max(x, y, na.rm = TRUE),
  )
```
:::

::: {.column width="25%"}
::: callout-warning
- Funzioni di **riassunto** (ad esempio, `min`, `max`):
    - Prendono: vettori.
    - Restituiscono: un singolo valore.
- Funzioni **vettoriali** (ad esempio, `pmin`, `pmax`):
    - Prendono: vettori.
    - Restituiscono: vettori (della stessa lunghezza dell'input).
:::
:::
:::


## Pull - `dplyr::pull`

Possiamo estrarre una singola colonna come vettore utilizzando `dplyr::pull()` (invece di usare la doppia parentesi quadra `[[`, in modo da rendere l'operazione compatibile con il pipe `|>`).

```{r}
library(dplyr)
db |>
  select(age, case) |>
  filter(case) |>
  pull(age) |>
  mean(na.rm = TRUE)
```


## Il Vostro turno

- usando la funzione `here` e `import` di `{rio}` importate il dataset `Copenhagen_clean.xlsx` (nella cartella `data-raw`).
- usando `dplyr::select()` selezionate le colonne `age`, `sex`, `weight`, `height` e `case`.
- usando `dplyr::filter()` selezionate le righe con `case == TRUE`.
- usando `dplyr::mutate()` calcolate il BMI come `weight/(height^2)`.
- usando `dplyr::pull()` estraete la colonna `BMI` e calcolate il suo valore medio (ignorando i valori mancanti).
- fate il tutto in una pipeline unica.


```{r}
#| echo: false
countdown(
  minutes = 3,
  left = "25%",
  right = "25%",
  top = "70%",
  bottom = 0,
  blink_colon = TRUE,
  play_sound = TRUE,
  margin = "5%",
  font_size = "4em"
)
```

## Riconoscimenti

Per creare questa lezione ho esplorato, utilizzato e adattato i contenuti delle seguenti risorse:

-   Materiale del corso [Carpentries](https://carpentries.org/)' [Programming with R](https://swcarpentry.github.io/r-novice-inflammation/).
-   [Carpentries](https://carpentries.org/)' [R for Reproducible Scientific Analysis](https://swcarpentry.github.io/r-novice-gapminder/).
-   [Hadley Wickham](https://hadley.nz/) [Advanced R - (2e)](https://adv-r.hadley.nz)
-   [R for Data Science (2e)](https://hadley.nz/) di [Hadley Wickham](https://r4ds.hadley.nz/)

Le diapositive sono state realizzate utilizzando [Posit](https://posit.co/) [Quarto](https://quarto.org/), sistema open-source di editoria scientifica e tecnica alimentato in R da [kintr](https://yihui.org/knitr/) (creato da [Yihui Xie](https://yihui.org/) ).

### License

```{=html}
 <p xmlns:cc="http://creativecommons.org/ns#" ><a rel="cc:attributionURL" href="https://github.com/CorradoLanera/sscg-informatica">Questo lavoro</a> di <a rel="cc:attributionURL dct:creator" property="cc:attributionName" href="https://github.com/CorradoLanera">Corrado Lanera</a> è offerto sotto licenza <a href="http://creativecommons.org/licenses/by/4.0/?ref=chooser-v1" target="_blank" rel="license noopener noreferrer" style="display:inline-block;">CC BY 4.0<img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/cc.svg?ref=chooser-v1"><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/by.svg?ref=chooser-v1"></a></p>
```
