---
title: '[Basi di R]{style="color:darkorange;"}'
subtitle: "~20 min"
format:
  revealjs:
    width:  1648 #(3/2)
    height: 1080
    logo: img/UBEP.png
    footer: "SSCG Informatica di Base - I anno"
    slide-number: true
    history: false
    preview-links: auto
    code-link: true
    chalkboard:
      src: src/chalkboard-base-r.json
bibliography: references.bib
---

```{r}
#| label: setup
#| include: false
knitr::opts_chunk$set(
  echo = TRUE
)
library(tidyverse)
library(countdown)
```

# Oggetti e vettori

## vettori (atomici)

I vettori atomici sono oggetti omogenei/piatti, cioè tutti gli oggetti che compongono la sequenza devono essere dello stesso tipo e non possono contenere altre sequenze (annidate).

Quattro tipi principali (`?typeof`) di vettori atomici:

::: columns
::: {.column width="30%"}
|         |               |
|---------|---------------|
| Logical | `?is.logical` |
:::

::: {.column width="70%"}
```{r}
#| output-location: column
typeof(TRUE)
```

```{r}
#| output-location: column
c(is.atomic(FALSE), is.logical(FALSE))
```
:::
:::

<br>

::: columns
::: {.column width="30%"}
|         |               |
|---------|---------------|
| Integer | `?is.integer` |
:::

::: {.column width="70%"}
```{r}
#| output-location: column
typeof(1:3)
```

```{r}
#| output-location: column
c(is.atomic(1:3), is.integer(1:3))
```
:::
:::

<br>

::: columns
::: {.column width="30%"}
|        |              |
|--------|--------------|
| Double | `?is.double` |
:::

::: {.column width="70%"}
```{r}
#| output-location: column
typeof(1.2)
```

```{r}
#| output-location: column
c(is.atomic(1.2), is.double(1.2))
```
:::
:::

<br>

::: columns
::: {.column width="30%"}
|           |                 |
|-----------|-----------------|
| Character | `?is.character` |
:::

::: {.column width="70%"}
```{r}
#| output-location: column
typeof("Hello supervisors")
```

```{r}
#| output-location: column
c( # line brakes don't brake execution
  is.atomic("Hello supervisors"),
  is.character("Hello supervisors")
)
```
:::
:::

<br>

::: columns
::: {.column width="30%"}
Gli elementi possono essere denominati
:::

::: {.column width="70%"}
```{r}
#| output-location: column
c(one = 1, two = 2, three = 3)
```
:::
:::

## (altri) vettori - Fattori

Altre strutture in R sono basate su vettori atomici, cioè sono di uno dei tipi di base ma hanno più *strutture* (strutture simili sono chiamate `?class`).

I **fattori** sono variabili discrete con etichette.

::: columns
::: {.column width="25%"}
|         |              |
|---------|--------------|
| Factors | `?is.factor` |
:::

::: {.column width="75%"}
```{r}
#| output-location: column
gender <- factor(
  c("male", "female", "female"),
  levels = c("female", "male", "other")
)
gender
```

```{r}
#| output-location: column
is.factor(gender)
```

```{r}
#| output-location: column
typeof(gender)
```

```{r}
#| output-location: column
class(gender)
```

```{r}
#| output-location: column
as.character(gender)
```

```{r}
#| output-location: column
as.integer(gender)
```
:::
:::

::: columns
::: {.column width="25%"}
|        |           |
|--------|-----------|
| Levels | `?levels` |
:::

::: {.column width="75%"}
```{r}
#| output-location: column
levels(gender)
```
:::
:::

::: callout-tip
È possibile esaminare la struttura interna di qualsiasi oggetto R utilizzando `?str`.
:::

::: columns
::: {.column width="25%"}
|           |        |
|-----------|--------|
| Struttura | `?str` |
:::

::: {.column width="75%"}
```{r}
#| output-location: column
str(gender)
```
:::
:::

## lista (di vettori)

Le liste sono oggetti eterogenei/annidabili, cioè gli oggetti che compongono la sequenza **possono** essere di tipi diversi e possono contenere altre sequenze (annidate).

::: columns
::: {.column width="15%"}
|      |         |
|------|---------|
| List | `?list` |
:::

::: {.column width="85%"}
```{r}
#| output-location: column
db_list <- list(
  age = c(70, 85, 69),
  height = c(1.5, 1.72, 1.81),
  at_risk = c(TRUE, FALSE, TRUE),
  gender = factor(
    c("male", "female", "female"),
    levels = c("female", "male", "other")
  )
)
db_list
```

<br>

```{r}
#| output-location: column
str(db_list)
```
:::
:::

## (altre) liste - data frame (e tibble)

Altre strutture in R sono basate su vettori di liste, cioè sono sequenze eterogenee di oggetti.

I **data frame** sono liste ordinati di vettori omogenei di uguali dimensioni. Si usano cioè per i dati tabellari:

::: foo-to-separate-the-list-from-the-below-columns
- elenco ordinato di colonne di informazioni, con intestazioni (`?names`)
- in una colonna c'è un solo tipo di informazione (omogenea)
- tutte le colonne hanno la stessa `?length`, cioè il numero di righe (`?nrow`)
:::

::: columns
::: {.column width="30%"}
|             |               |
|-------------|---------------|
| Data frame | `?data.frame` |

::: callout-tip
Durante il corso vedremo, spiegheremo e useremo le *tibble* (dal pacchetto `{tibble}`): una struttura moderna, migliorata, meglio visualizzata e con una struttura più rigorosa e coerente rispetto ai data frame standard.
:::
:::

::: {.column width="70%"}
```{r}
#| output-location: column
db_df <- data.frame(
  age = c(70, 85, 69),
  height = c(1.5, 1.72, 1.81),
  at_risk = c(TRUE, FALSE, TRUE),
  gender = factor(
    c("male", "female", "female"),
    levels = c("female", "male", "other")
  )
)
db_df
```

```{r}
#| output-location: column
names(db_df)
```

```{r}
#| output-location: column
nrow(db_df)
```

```{r}
#| output-location: column
ncol(db_df)
```

```{r}
#| output-location: column
dim(db_df)
```
:::
:::

## *vettori* come treni

::: callout-important
R funziona solo su vettori di due tipi:

- **Atomici** (omogenei / piatti)
- **Liste** (eterogeneo / annidato)
:::

Pensate agli oggetti in R (qualsiasi oggetto in R!) come a un treno (atomico o a lista) composto da vagoni:

- un treno (cioè un vettore) è una sequenza di vagoni (cioè oggetti, omogenei o eterogenei, eventualmente altri treni)
- i vagoni hanno un contenuto (cioè i dati che contengono)
- i vagoni possono avere delle etichette (cioè dei nomi)

![`x <- list(a = 1:3, b = "a", 4:6)` (image adapted from [Advanced-R](https://adv-r.hadley.nz/subsetting.html))](img/train-labels.png)

## Sottoinsieme - sottoinsieme  {.smaller}

::: callout-important
Si può parlare di *sottoinsieme* di oggetti (ad esempio, un treno) come di due operazioni principali:

- creare un altro oggetto (ad esempio, un altro treno) con un sottoinsieme dei suoi elementi (ad esempio, i vagoni)
- estrarre il contenuto di un (singolo) oggetto (ad esempio, il contenuto di un vagone).

È possibile selezionare più di un oggetto/*vagone* quando si effettua una sottosezione, ma un singolo oggetto solo quando si effettua l'*estrazione*!
:::

Tre modi per identificare gli elementi (ad esempio, i vagoni):

::: columns
::: {.column width="30%"}
|          |     |
|----------|-----|
| Original |     |
:::

::: {.column width="70%"}
```{r}
#| output-location: column
db_df
```
:::
:::


::: columns
::: {.column width="30%"}
|                    |     |
|--------------------|-----|
| Sottoinsieme per posizione | `[` |
:::

::: {.column width="70%"}
```{r}
#| output-location: column
db_df[c(2, 3)]
```
:::
:::

::: columns
::: {.column width="30%"}
|                 |     |
|-----------------|-----|
| Sottoinsieme per nomi | `[` |
:::

::: {.column width="70%"}
```{r}
#| output-location: column
db_df[c("height", "age")]
```
:::
:::

::: columns
::: {.column width="30%"}
|                                       |     |
|---------------------------------------|-----|
| Sottoinsieme per logica[^05-data-structure-3] | `[` |
:::

::: {.column width="70%"}
```{r}
#| output-location: column
db_df[c(TRUE, FALSE, FALSE, TRUE)]
```
:::
:::



[^05-data-structure-3]: Il vettore di sottoinsiemi logici **deve** avere la stessa `?length` dell'oggetto (ad esempio, il numero di vagoni del treno)..


## sottoselezione di tabelle di dati - coordinate [optional] {.smaller}

::: callout-important
Un data frame (e `tibble`) può essere visto come una "matrice" (o una tabella).
:::

I valori dei frame di dati possono essere suddivisi utilizzando la notazione "[righe, colonne]".


::: columns
::: {.column width="50%"}
|             |                |
|-------------|----------------|
| coordinate | `[rows, cols]` |
:::

::: {.column width="50%"}
```{r}
#| output-location: column
db_df[3, 2]
```

```{r}
#| output-location: column
db_df[3, "age"]
```
:::
:::

::: columns
::: {.column width="50%"}
|                                    |                          |
|------------------------------------|--------------------------|
| chiedere *niente*<br>ottenere *tutto* | `[, cols]`<br>`[rows, ]` |
:::

::: {.column width="50%"}
```{r}
#| output-location: column
db_df[, "age"]
```

```{r}
#| output-location: column
db_df[3, ]
```
:::
:::

::: columns
::: {.column width="50%"}
|                    |     |
|--------------------|-----|
| selezione multipla | `[` |

:::

::: {.column width="50%"}
```{r}
#| output-location: column
db_df[3, 1:2]
```

```{r}
#| output-location: column
db_df[3:2, c(2, 4)]
```
:::
:::

## Sottoselezionare tabelle di dati - estrazione [side]

::: callout-important
Si può parlare di *sottoselezione* di oggetti (ad esempio, un treno) come di due operazioni principali:

- creare un altro oggetto (ad esempio, un altro treno) con un sottoinsieme dei suoi elementi (ad esempio, i vagoni)
- estrarre il contenuto di un (singolo) oggetto (ad esempio, il contenuto di un vagone).

È possibile selezionare più di un oggetto/*vagone* quando si effettua una sottosezione, ma un singolo oggetto solo quando si effettua l'*estrazione*!
:::

Due modi per identificare un (singolo!) elemento (ad esempio, un carro):

::: foo-to-separate-the-list-from-the-below-columns
- con la sua posizione.
- con il suo nome, se ha un nome.
:::

::: columns
::: {.column width="30%"}
|            |      |
|------------|------|
| Estrazione | `[[` |
:::

::: {.column width="70%"}
```{r}
#| output-location: column
db_df[[1]]
```

```{r}
#| output-location: column
db_df[["height"]]
```
:::
:::

::: columns
::: {.column width="30%"}
|            |                           |
|------------|---------------------------|
| Estrazione | `$`[^05-data-structure-4] |
:::

::: {.column width="70%"}
```{r}
#| output-location: column
db_df$height
```
:::
:::

[^05-data-structure-4]: Sconsigliato nell'uso non interattivo a causa dei risultati imprevedibili dovuti alla corrispondenza parziale (`?"$"` )..


## Copy-on-modify

> Nota bene: R usa la strategia di *copy-on-modify* per la gestione della memoria.

Ciò significa che quando si modifica un oggetto, R crea una copia modificata dell'oggetto invece di modificare l'oggetto originale in loco.

```{r}
#| output-location: column
x <- c(1, 2, 3)
y <- x
y[1] <- 10
x
y
```
In questo esempio, quando modifichiamo `y`, R crea una copia di `x` e modifica la copia, lasciando `x` invariato.


## Pipe (Esercizio mentale)

Supponiamo di avere le seguenti funzioni:

```{r}
add <- function(x, y) x + y
multiply_by <- function(x, by) x * by
divide_by_two <- function(x) x / 2
```

::: columns
::: {.column width="50%"}
Fate finta che sia un problema difficile e che vogliate utilizzare queste funzioni **solo** per trovare un'area trapezoidale con i seguenti dati già definiti nella vostra sessione R:

```{r}
a <- 2
b <- 3
h <- 4
```


:::

::: {.column width="50%"}
Area = $\frac{a+b}{2}h$

![](img/trapezoid.png)
:::
:::


## Sovrascrivere il risultato [side-by-side]

```{r}
res <- add(a, b)
res <- divide_by_two(res)
res <- multiply_by(res, h)
res
```

- E se dovessimo fare il debug di questo codice? Se commettiamo degli errori, dovremo rieseguire l'intera pipeline dall'inizio!

- È difficile seguire cosa viene cambiato a ogni riga, considerando che abbiamo ripetuto `res` (che è il nome del nostro risultato *finale*) per sei volte!

> Cambiare il nome ogni volta può sicuramente risolvere il problema 2. Vediamo.

## Creare oggetti intermedi [side-by-side]

```{r}
bases <- add(a, b)
half_bases <- divide_by_two(bases)
area <- multiply_by(half_bases, h)
area
```

-   Non abbiamo ripetuto i nomi, ma ora abbiamo molti nomi (e oggetti!) inutili definiti nel nostro spazio di lavoro.

. . .

Dobbiamo pensare a nomi significativi (non usuali!) per tutti gli oggetti intermedi, perché sicuramente vogliamo evitare situazioni come la seguente

```{r}
res_1 <- add(a, b)
res_2 <- divide_by_two(res_1)
res_final <- multiply_by(res_2, h)
res_final
```

Il che comporta il peggio di entrambe le cose, aggiungendo il difficile debug e la correzione di tutti i numeri nelle modifiche intermedie avvenute; o, peggio ancora, iniziando ad avere nomi di variabili con numeri non sequenziali!

> Quindi possiamo comporre le funzioni una dentro l'altra per ottenere direttamente il risultato! Vediamo

## Comporre le chiamate di funzione [side-by-side]

```{r}
res <- multiply_by(divide_by_two(add(a, b)), h)
res
```

1.  Piuttosto illeggibile ed estremamente difficile da seguire; soprattutto perché ogni argomento è a distanza crescente dai nomi delle funzioni (ad esempio, `moltiply_by` è il primo nome che compare e il suo secondo argomento `h` è l'ultimo).

. . .

Potremmo migliorare la leggibilità indentando il nostro codice (cosa sicuramente buona da fare)

```{r}
res <- multiply_by(
  divide_by_two(
    add(a, b)
  ),
  h
)
res
```

Ma rimane abbastanza difficile capire *cosa* fa la funzione; almeno, non è immediato e naturale!

> Ecco perché abbiamo bisogno di uno strumento, che è il *pipe*. Diamogli un'occhiata.

## Usare le pipe [side-by-side]

Nella sua definizione più semplice la pipe (che ora è un simbolo nativo in R `|>`) è un operatore che prende il risultato di qualsiasi cosa venga valutata alla sua sinistra e lo usa come primo input della chiamata di funzione alla sua destra (che deve essere una chiamata di funzione vera e propria, con almeno un argomento)

::: columns
::: {.column width="50%"}
::: callout-tip
Dal punto di vista matematico, pipe trasforma $f(x,\ y)$ in $x\ |> f(y)$. Così possiamo ristrutturare $f(g(x))$ come $g(x)\ |> f()$.
:::
:::

::: {.column width="50%"}
::: callout-tip
Cercate di leggere il pipe come "e poi...".
:::
:::
:::

```{r}
res <- a |>
  add(b) |>
  divide_by_two() |>
  multiply_by(h)
res
```

1.  Ogni argomento è esattamente accanto alla sua chiamata di funzione
2.  Si crea solo l'oggetto risultato
3.  Possiamo naturalmente *leggere* cosa fa il codice: "prendi a, *e poi...* aggiungi b, *e poi...* dividi il risultato per due, *e poi...* moltiplica il risultato per h"; e questo è tutto, la formula ortografica delle aree trapezoidali!


## Il Vostro turno + Pausa 10 minuti

-  create un data frame (o meglio, una tibble) con tre colonne e quattro righe (dati fittizi):
   - età (numeric)
   - sesso (factor con livelli "M", "F", "other")
   - outcome (logical)
- vi viene in mente qualche statistica descrittiva semplice da calcolare su queste variabili?
- potete calcolare queste statistiche usando le funzioni di base di R?
- potete usare le pipe per rendere il vostro codice più leggibile?


```{r}
#| echo: false
countdown(
  minutes = 10,
  left = "25%",
  right = "25%",
  top = "70%",
  bottom = 0,
  blink_colon = TRUE,
  play_sound = TRUE,
  margin = "5%",
  font_size = "4em"
)
```


## Riconoscimenti

Per creare questa lezione ho esplorato, utilizzato e adattato i contenuti delle seguenti risorse:

- Materiale del corso [Carpentries](https://carpentries.org/)' [Programming with R](https://swcarpentry.github.io/r-novice-inflammation/).
- [Carpentries](https://carpentries.org/)' [R for Reproducible Scientific Analysis](https://swcarpentry.github.io/r-novice-gapminder/).
- [Hadley Wickham](https://hadley.nz/) [Advanced R - (2e)](https://adv-r.hadley.nz)
- [R for Data Science (2e)](https://hadley.nz/) di [Hadley Wickham](https://r4ds.hadley.nz/)

Le diapositive sono state realizzate utilizzando [Posit](https://posit.co/) [Quarto](https://quarto.org/), sistema open-source di editoria scientifica e tecnica alimentato in R da [kintr](https://yihui.org/knitr/) (creato da [Yihui Xie](https://yihui.org/) ).


### License

```{=html}
 <p xmlns:cc="http://creativecommons.org/ns#" ><a rel="cc:attributionURL" href="https://github.com/CorradoLanera/sscg-informatica">Questo lavoro</a> di <a rel="cc:attributionURL dct:creator" property="cc:attributionName" href="https://github.com/CorradoLanera">Corrado Lanera</a> è offerto sotto licenza <a href="http://creativecommons.org/licenses/by/4.0/?ref=chooser-v1" target="_blank" rel="license noopener noreferrer" style="display:inline-block;">CC BY 4.0<img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/cc.svg?ref=chooser-v1"><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/by.svg?ref=chooser-v1"></a></p>
```
